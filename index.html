<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>URBAN SCANNER</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #ff3300; font-family: 'Courier New', Courier, monospace; }
        
        #intro-overlay {
            position: absolute; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(20,0,0,1) 0%, rgba(0,0,0,1) 100%);
            display: flex; justify-content: center; align-items: center;
            z-index: 500; padding: 20px; 
            transition: opacity 0.4s ease-out; 
        }
        
        .glitch-box { 
            border: 2px solid #ff3300; 
            padding: 40px; 
            max-width: 800px; 
            background: rgba(10,0,0,0.95);
            box-shadow: 0 0 30px rgba(255, 51, 0, 0.3), inset 0 0 20px rgba(255, 51, 0, 0.1);
        }
        
        .glitch-text { font-size: 14px; line-height: 1.6; color: #ff3300; text-transform: uppercase; animation: glitch 2s infinite; }
        h1 { font-size: 2.5em; letter-spacing: 10px; text-align: center; color: #fff; margin-bottom: 30px; text-shadow: 0 0 10px #ff3300; }

        @keyframes glitch {
            0% { text-shadow: 2px 0 red, -2px 0 blue; transform: translate(0); }
            20% { text-shadow: -2px 0 red, 2px 0 blue; transform: translate(-2px, 1px); }
            100% { text-shadow: -2px 0 red, 2px 0 blue; transform: translate(0); }
        }

        .terminal-box {
            position: absolute;
            background: rgba(0,0,0,0.85);
            border-left: 4px solid #ff3300;
            padding: 15px;
            z-index: 100;
            font-size: 10px;
            text-transform: uppercase;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 15px rgba(255, 51, 0, 0.2);
        }

        #system-log { top: 30px; left: 30px; min-width: 220px; }
        
        /* UI NOME DISTRETTO */
        #location-ui { 
            bottom: 40px; left: 50%; transform: translateX(-50%); 
            text-align: center; 
            min-width: 55vw;
            border-left: none;
            border-bottom: 2px solid #ff3300;
            padding-bottom: 15px;
            overflow: visible;
        }

        #distretto-nome {
            font-size: 22px;
            font-weight: bold; 
            letter-spacing: 1px;
            color: #fff;
            white-space: pre; 
            display: inline-block;
            text-shadow: 0 0 12px rgba(255, 51, 0, 0.8);
        }

        .gesture-status {
            display: block;
            margin-top: 15px; 
            color: #ff3300;
            font-size: 11px;
            letter-spacing: 5px;
            font-weight: 900;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.03); color: #fff; }
            100% { opacity: 0.3; transform: scale(1); }
        }
        
        #webcam-monitor { top: 30px; right: 30px; padding: 5px; width: 220px; border-left: none; border-right: 4px solid #ff3300; }
        #radar-container { position: relative; width: 210px; height: 150px; overflow: hidden; border: 1px solid #ff330044; }
        
        video { 
            width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); 
            filter: sepia(100%) saturate(500%) hue-rotate(-55deg) contrast(1.5);
            transition: filter 0.1s ease;
        }
        .v-glitch { filter: sepia(100%) saturate(1000%) hue-rotate(-55deg) contrast(3) invert(0.1) brightness(2) !important; mix-blend-mode: screen; }
        
        .scan-line {
            position: absolute; top: 0; left: 0; width: 100%; height: 3px;
            background: #fff;
            box-shadow: 0 0 15px #ff3300, 0 0 30px #ff3300;
            z-index: 110;
            animation: moveScan 3s linear infinite;
        }
        @keyframes moveScan { 0% { top: -5%; } 100% { top: 105%; } }
    </style>
</head>
<body>

    <div id="intro-overlay">
        <div class="glitch-box">
            <h1 class="glitch-text">URBAN SCANNER - GENTRIFICAZIONE URBANA</h1>
            <div class="glitch-text">
            IL TESSUTO URBANO È SOTTOPOSTO A RICONFIGURAZIONE SPECULATIVA. UN "CORPO ESTERNO" ISTITUZIONALE SOVRASCRIVE LA REALTÀ LOCALE: LO SPAZIO NON VIENE PIÙ ABITATO, MA AMMINISTRATO COME COORDINATA DI PROFITTO PER GRANDI CAPITALI.<br><br>
            LE RADICI SOCIALI VENGONO ESPULSE PER FAR POSTO AL MERCATO. IL GESTO DEL CITTADINO VIENE TRADITO: LA PERIFERIA CHE CHIEDEVA UN FUTURO PER I PROPRI FIGLI RICEVE UN FUTURO PER GLI INVESTITORI. DOVE IL TEMPO SEMBRA FOSSILIZZATO, GLI AFFITTI DIVENTANO MURI.<br><br>
            L'URBAN SCANNER È UN SIMULATORE DI POTERE. INDICARE DIVENTA UN ATTO DI ACCUSA E UN ESERCIZIO DI CONSAPEVOLEZZA: TRACCIA UN CONFINE TRA IL PRESENTE E UN LUOGO MERCIFICATO CHE CESSA DI ESSERE UN "POSTO DI CORPI".<br><br>
            [COMANDI GESTUALI]:<br>
            1. MOSTRA LA MANO APERTA: INIZIALIZZA / CAMBIA PERIFERIA.<br>
            2. PUNTA L'INDICE: SPOSTA LA LENTE DI SCANSIONE.<br>
            3. NASCONDI LA MANO: STAND-BY DEL SISTEMA.<br><br>
                <center id="status-msg" style="border: 1px solid #ff3300; padding: 10px; background: rgba(255,51,0,0.1)">[ ATTESA ASSET... ]</center>
            </div>
        </div>
    </div>

    <div id="system-log" class="terminal-box">
        <div style="color: #ff3300; border-bottom: 1px solid #ff330033; padding-bottom: 5px; margin-bottom: 8px; font-weight: bold; letter-spacing: 2px;">ANALISI E CONTROLLO SISTEMA</div>
        [STATUS]: <span id="s1" style="color: #fff">BOOTING</span><br>
        [TRACKING]: <span id="s2" style="color: #fff">OFFLINE</span><br>
        [MOTION_STRESS]: <span id="g-index" style="color: #fff">0.00</span><br>
        [Z_DEPTH]: <span id="z-depth" style="color: #fff">0.00</span>
    </div>

    <div id="location-ui" class="terminal-box">
        <span id="distretto-nome">INIZIALIZZAZIONE...</span>
        <div class="gesture-status">>> SISTEMA DI SCANSIONE ATTIVO <<</div>
    </div>

    <div id="webcam-monitor" class="terminal-box">
        <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-weight: bold;">
            <span>RICEZIONE VIDEO ATTIVA</span>
            <span id="rec-dot" style="color: #ff3300; animation: pulse 0.5s infinite;">●</span>
        </div>
        <div id="radar-container">
            <div class="scan-line"></div>
        </div>
    </div>

    <script>
        const distretti = [
            { nome: "PERIFERIA_01: SAN POLO_Via Giovanni Cimabue, 34", p: "periferia1.jpg", c: "centro1.jpg", g: "88%" },
            { nome: "PERIFERIA_02: SAN POLO_Via Andrea del Verrocchio, 419", p: "periferia2.jpg", c: "centro2.jpg", g: "92%" },
            { nome: "PERIFERIA_03: MOMPIANO_Via Bligny, 32-48", p: "periferia3.jpg", c: "centro3.jpg", g: "74%" },
            { nome: "PERIFERIA_04: MOMPIANO_Piazzetta Santi Francesco e Chiara", p: "periferia5.jpg", c: "centro5.jpg", g: "81%" },
            { nome: "PERIFERIA_05: SANPOLINO_Via degli Alpini, 43", p: "periferia4.jpg", c: "centro4.jpg", g: "95%" }
        ];

        let currentId = 0, prevId = 0; // prevId aggiunto per transizione
        let imgP = [], imgC = [];
        let handLandmarks = [], video, hands;
        let smoothX = 0, smoothY = 0, rotAngle = 0;
        let lastX = 0, lastY = 0, handSpeed = 0, handZ = 0;
        let appStarted = false, isResetting = false;
        let transitionAlpha = 255, masterAlpha = 255;
        let finalFlash = 0, assetsLoaded = 0, canChangeDistrict = true;

        function preload() {
            distretti.forEach((d, i) => {
                imgP[i] = loadImage(d.p, assetLoadedCallback);
                imgC[i] = loadImage(d.c, assetLoadedCallback);
            });
        }

        function assetLoadedCallback() {
            assetsLoaded++;
            if (assetsLoaded >= 2) document.getElementById('status-msg').innerHTML = "[ MOSTRA LA MANO APERTA PER ATTIVARE LO SCANNER ]";
            if (assetsLoaded === distretti.length * 2) {
                const sl = document.getElementById('asset-load-status');
                if(sl) sl.innerText = "STABLE";
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            video = createCapture(VIDEO);
            video.size(210, 150);
            video.parent('radar-container');
            
            hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6 });
            
            hands.onResults(results => {
                handLandmarks = results.multiHandLandmarks;
                const v = document.querySelector('video');
                
                if(handLandmarks && handLandmarks.length > 0) {
                    let landmarks = handLandmarks[0];
                    document.getElementById('s2').innerText = "LOCKED";
                    
                    let currentX = landmarks[8].x;
                    let currentY = landmarks[8].y;
                    handSpeed = dist(lastX, lastY, currentX, currentY) * 150;
                    lastX = currentX; lastY = currentY;
                    
                    let wrist = landmarks[0];
                    let middle = landmarks[9];
                    handZ = dist(wrist.x, wrist.y, middle.x, middle.y);
                    
                    document.getElementById('g-index').innerText = handSpeed.toFixed(2);
                    document.getElementById('z-depth').innerText = handZ.toFixed(2);

                    let contrast = map(handZ, 0.1, 0.5, 1.5, 6);
                    let brightness = map(handSpeed, 0, 15, 1, 3);
                    let blur = handSpeed > 10 ? `blur(${floor(handSpeed/2)}px)` : 'blur(0px)';
                    v.style.filter = `sepia(100%) saturate(800%) hue-rotate(-55deg) contrast(${contrast}) brightness(${brightness}) ${blur}`;
                    
                    if(handSpeed > 12) {
                        v.classList.add('v-glitch');
                        v.style.transform = `scaleX(-1) translate(${random(-10,10)}px, ${random(-10,10)}px)`;
                    } else {
                        v.classList.remove('v-glitch');
                        v.style.transform = `scaleX(-1)`;
                    }

                    if (!isResetting) checkHandOpen(landmarks);
                } else { 
                    document.getElementById('s2').innerText = "SEARCHING..."; 
                    v.classList.remove('v-glitch');
                    v.style.filter = `sepia(100%) saturate(500%) hue-rotate(-55deg) contrast(1.5)`;
                    v.style.transform = `scaleX(-1)`;
                    handSpeed = 0;
                }
            });

            new Camera(video.elt, {
                onFrame: async () => { await hands.send({image: video.elt}); },
                width: 210, height: 150
            }).start();
            document.getElementById('s1').innerText = "KERNEL_RUNNING";
        }

        function checkHandOpen(landmarks) {
            const wrist = landmarks[0];
            const fingerTips = [landmarks[8], landmarks[12], landmarks[16], landmarks[20]];
            let openFingers = 0;
            fingerTips.forEach(tip => { if (dist(wrist.x, wrist.y, tip.x, tip.y) > 0.35) openFingers++; });

            if (openFingers >= 3) {
                if (!appStarted && !isResetting && assetsLoaded >= 2) startApp();
                else if (appStarted && canChangeDistrict) nextDistrict();
            }
        }

        function startApp() {
            isResetting = true;
            finalFlash = 255; 
            setTimeout(() => {
                document.getElementById('intro-overlay').style.opacity = '0';
                setTimeout(() => { 
                    document.getElementById('intro-overlay').style.display = 'none';
                    appStarted = true;
                    currentId = 0;
                    prevId = 0;
                    updateUIDistretto();
                    isResetting = false;
                    canChangeDistrict = false;
                    setTimeout(() => { canChangeDistrict = true; }, 1500);
                }, 400);
            }, 100);
        }

        function nextDistrict() {
            if (currentId >= distretti.length - 1) resetToMenu();
            else {
                prevId = currentId; // Salva il vecchio distretto
                currentId++;
                transitionAlpha = 0; // Reset alpha per la nuova immagine
                canChangeDistrict = false;
                updateUIDistretto();
                setTimeout(() => { canChangeDistrict = true; }, 1200);
            }
        }

        function resetToMenu() {
            isResetting = true;
            let crashInterval = setInterval(() => {
                masterAlpha -= 20;
                finalFlash = random(100, 255);
                if (masterAlpha <= 0) {
                    clearInterval(crashInterval);
                    appStarted = false;
                    const intro = document.getElementById('intro-overlay');
                    intro.style.display = 'flex';
                    setTimeout(() => { intro.style.opacity = '1'; }, 50);
                    setTimeout(() => {
                        isResetting = false;
                        masterAlpha = 255;
                        finalFlash = 0;
                    }, 1500);
                }
            }, 30);
        }

        function draw() {
            background(0);
            if (finalFlash > 0) drawGlitchOverlay();
            if (!appStarted) return;

            push();
            if (imgP[currentId]) {
                let drift = map(handSpeed, 0, 30, 0, 15);
                
                // RENDERING TRANSIZIONE
                if (transitionAlpha < 255) {
                    // Disegna la vecchia immagine sotto
                    tint(255, (255 - transitionAlpha) * (masterAlpha/255));
                    image(imgP[prevId], 0, 0, width, height);
                    
                    // Disegna la nuova immagine sopra con glitch
                    applyGlitch();
                    tint(255, transitionAlpha * (masterAlpha/255));
                    image(imgP[currentId], random(-5, 5), 0, width, height);
                    transitionAlpha += 15; // Velocità della dissolvenza
                } else {
                    // Normale visualizzazione con Aberrazione
                    if(drift > 2) {
                        push();
                        blendMode(SCREEN);
                        tint(255, 100, 100, masterAlpha);
                        image(imgP[currentId], drift + random(-2,2), 0, width, height);
                        tint(100, 255, 255, masterAlpha);
                        image(imgP[currentId], -drift + random(-2,2), 0, width, height);
                        pop();
                    } else {
                        tint(255, masterAlpha);
                        image(imgP[currentId], 0, 0, width, height);
                    }
                }
            }

            if (handLandmarks && handLandmarks.length > 0) {
                let tip = handLandmarks[0][8];
                smoothX = lerp(smoothX, (1 - tip.x) * width, 0.2);
                smoothY = lerp(smoothY, tip.y * height, 0.2);
                
                let lw = 450 + (handZ * 400);
                let lh = 260 + (handZ * 200);
                
                if(imgC[currentId]) {
                    let sw = (lw / width) * imgC[currentId].width;
                    let sh = (lh / height) * imgC[currentId].height;
                    let sx = (smoothX / width) * imgC[currentId].width - sw / 2;
                    let sy = (smoothY / height) * imgC[currentId].height - sh / 2;
                    
                    push();
                    // Anche la lente segue la dissolvenza se necessario
                    let lensAlpha = (transitionAlpha < 255) ? transitionAlpha : 255;
                    tint(255, lensAlpha * (masterAlpha/255));
                    copy(imgC[currentId], sx, sy, sw, sh, smoothX - lw/2, smoothY - lh/2, lw, lh);
                    pop();
                }
                drawEnhancedHUD(smoothX, smoothY, lw, lh);
            }

            drawVignette();
            drawGrid();
            pop();
        }

        function drawGlitchOverlay() {
            for(let i=0; i<15; i++){
                fill(random() > 0.5 ? 255 : color(255, 51, 0), finalFlash);
                rect(0, random(height), width, random(1, 30));
            }
            finalFlash -= 10;
        }

        function applyGlitch() {
            for (let i = 0; i < 5; i++) {
                let y = random(height);
                let h = random(10, 40);
                copy(imgP[currentId], 0, y, width, h, random(-30, 30), y, width, h);
            }
        }

        function drawVignette() {
            push();
            noFill();
            for(let i = 0; i < 180; i += 3) {
                let alpha = map(i, 0, 180, 230, 0);
                stroke(0, alpha * (masterAlpha/255));
                strokeWeight(4);
                rect(i, i, width - i*2, height - i*2);
            }
            pop();
        }

        function drawEnhancedHUD(x, y, w, h) {
            push();
            let col = color(255, 51, 0, masterAlpha);
            let white = color(255, 255, 255, masterAlpha);
            stroke(col);
            noFill();
            
            strokeWeight(2);
            let b = 35;
            line(x-w/2, y-h/2, x-w/2+b, y-h/2); line(x-w/2, y-h/2, x-w/2, y-h/2+b);
            line(x+w/2, y-h/2, x+w/2-b, y-h/2); line(x+w/2, y-h/2, x+w/2, y-h/2+b);
            line(x-w/2, y+h/2, x-w/2+b, y+h/2); line(x-w/2, y+h/2, x-w/2, y+h/2-b);
            line(x+w/2, y+h/2, x+w/2-b, y+h/2); line(x+w/2, y+h/2, x+w/2, y+h/2-b);

            translate(x, y);
            rotAngle += 0.05 + (handSpeed * 0.01);
            
            strokeWeight(1);
            ellipse(0, 0, 120, 120);
            
            push();
            rotate(rotAngle);
            strokeWeight(3);
            arc(0, 0, 145, 145, 0, HALF_PI);
            arc(0, 0, 145, 145, PI, PI + HALF_PI);
            pop();

            push();
            rotate(-rotAngle * 0.5);
            drawingContext.setLineDash([5, 10]);
            ellipse(0, 0, 180, 180);
            pop();

            fill(col);
            noStroke();
            push(); rotate(QUARTER_PI); rect(0,0,12,12); pop();

            fill(white);
            textSize(10);
            textAlign(LEFT);
            text(`SCAN_X: ${floor(x)}`, w/2 + 15, -h/2 + 10);
            text(`STRESS: ${handSpeed.toFixed(1)}`, w/2 + 15, -h/2 + 25);
            
            stroke(col);
            noFill();
            rect(0, h/2 + 15, 180, 2);
            fill(col);
            rect(-90 + (frameCount%180), h/2 + 15, 30, 4);
            pop();
        }

        function drawGrid() {
            push();
            stroke(255, 51, 0, 35 * (masterAlpha/255)); 
            strokeWeight(1); 
            for(let i = 0; i < width; i += 100) line(i, 0, i, height);
            for(let i = 0; i < height; i += 100) line(0, i, width, i);
            
            stroke(255, 51, 0, 80);
            let scanY = (frameCount * 3) % height;
            line(0, scanY, width, scanY);
            pop();
        }

        function updateUIDistretto() { 
            const el = document.getElementById('distretto-nome');
            if(el) {
                el.innerText = "";
                let fullText = distretti[currentId].nome;
                let charIndex = 0;
                let interval = setInterval(() => {
                    el.innerText += fullText[charIndex];
                    charIndex++;
                    if(charIndex >= fullText.length) clearInterval(interval);
                }, 20);
            }
        }
        
        function windowResized() { resizeCanvas(windowWidth, windowHeight); }
    </script>
</body>
</html>